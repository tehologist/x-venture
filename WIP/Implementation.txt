-----------------------------
X-Venture Implementation Doc
-----------------------------

Parser
---------
The parser is the first object which working on. The parser is a simple bnf tree made using pyparsing. It is divided into a grammar and parsar file. The grammar basically describes the most used commands a player will send. The parser in turn will take a textual string, parse the words and seperate this into a message in which the engine can use to call methods on objects.

Message Stack
---------------
The message stack is the second phase of the engine. Basically it will search in order by room->object, player_objects->player. Any object has first chance to respond, will first check to see if method exists, then will try to execute method. If method passes will continue down the stack till something is capable of responding. If more than one object has method and neither passes. It will try to resolve by name, otherwise first method will process the message. Then the stack will terminate at that position. This allows any object to overload basic commands of a player. For instance player who is in a bear trap will be unable to leave the room because the beartrap will respond to any go commands the player issues.

Events
---------
Any method can send events. The events are in the form of onMove, onSay, onLook. These will respond to evt_look, evt_say, etc. These are generated accordingly. A player enters a room, evt_enter is sent to room as evt_enter(player_id). The room can then handle this by parsing to see if it has an on_enter(self, player_id) method, if not it will continue down the stack to see if any object in the room has such a method.

Daemons
----------
Daemons are basically just methods that are to be called later. The objects in the world will be able to register methods with whatever arguments to be called either at a later turn or time depending on engine used (turn based single player, or heartbeat /time based). The object will call a register function similar to this, engine.register(objectInstance.method(args, turns/time in seconds).

Moving objects
-----------------
Objects will not so much be moved as reparented. Objects which contain other objects will keep a list. When object moves will be removed from list and added to its new parents, objects location_id will also be updated. All objects are aware of their children and parent.

Room Placement
-----------------
Rooms will exist in a 3d imaginary space which is attached to a realm name. This will be in the following format realm_name.x(0).y(0).z(0). These numberals are allowed to be negative and must be chars not numerals. This is to allow easy finding using function string.find("realm_name.x(0).y(0).z(0)"). The locations of all rooms will be a dictionary key with corresponding object_id when room is created. All object id's will be unique per instance.

Persistance
-----------------
PyYaml is being used to represent the data portion of objects. PyYaml is capable of storing objects as strings for easy storage and recovery in nonbinary format. To support this, no object is allowed to directly keep instance of another object. These will be kept in lists, and generated/stored as needed. This will help minimalize imports, as well as allowing easy changing and editing of objects by nonprogrammers. 
